# 해시 테이블 (Hash Table)

## 개념
- **해시 테이블(Hash Table)** 은 **키(Key)** 와 **값(Value)** 을 한 쌍으로 저장하는 자료구조이다.
- **해시 함수(Hash Function)** 를 사용하여 키를 배열의 인덱스로 변환하고, 해당 위치에 데이터를 저장하여 빠른 검색 속도를 제공한다.
- 이 구현체에서는 **체이닝(Chaining)** 기법을 사용하여 해시 충돌(Hash Collision)을 해결하였으며, 충돌 시 **이중 연결 리스트(Doubly Linked List)** 에 데이터를 저장한다.

<br/>

## 추상자료형 ADT
| 프로퍼티 / 메서드 | 시간 복잡도 (평균) | 설명 |
| --- | --- | --- |
| `put(key, value)` | $O(1)$ | 키와 값을 저장한다. 이미 존재하는 키라면 값을 업데이트한다. |
| `get(key)` | $O(1)$ | 키에 해당하는 값을 반환한다. 키가 없으면 `null`을 반환한다. |
| `remove(key)` | $O(1)$ | 키에 해당하는 데이터를 삭제하고, 삭제된 값을 반환한다. |
| `contains(key)` | $O(1)$ | 해당 키가 테이블에 존재하는지 여부를 반환한다. |
| `size` | $O(1)$ | 현재 테이블에 저장된 데이터의 개수를 반환한다. (Getter로 구현) |
| `isEmpty()` | $O(1)$ | 테이블이 비어있는지 여부를 반환한다. |
| `clear()` | $O(1)$ | 테이블의 모든 데이터를 삭제하고 초기화한다. |

<br/>

## 핵심 로직

### 해시 함수 (Hash Function)
- 문자열 키를 입력받아 고정된 크기의 배열 인덱스로 변환한다.
- 각 문자의 아스키 코드 값에 소수(Prime Number, 37)를 곱하고 누적하여 해시 값을 계산한 뒤, 테이블 크기로 나눈 나머지를 사용한다.

### 소수 사용 이유
- **패턴 제거** : 입력 데이터(key)가 일정한 규칙을 가지고 있더라도, 소수를 곱하고 나누는 과정에서 그 규칙성이 깨진다.
- **균등한 분포**
  - 소수는 다른 숫자와 공약수를 거의 가지지 않기 때문에, 해시 결과값이 테이블의 특정 구역에 뭉치지 않고 전체 공간에 골고루 퍼질 수 있도록 도와준다. 
  - 결과적으로 해시 테이블의 성능을 최적으로 유지할 수 있다.

### 충돌 해결 (Collision Resolution) - 체이닝 (Chaining)
- 서로 다른 키가 같은 해시 값(인덱스)을 가질 경우, 해당 인덱스에 **이중 연결 리스트(Doubly Linked List)** 를 생성하여 데이터를 연결한다.
- 데이터를 저장할 때(`put`), 해당 인덱스의 리스트를 순회하여 키가 이미 존재하는지 확인한다.
  - 존재하면 값을 업데이트한다.
  - 존재하지 않으면 리스트의 맨 뒤에 새로운 데이터를 추가한다.

### 성능 최적화
- **Size 관리**: `size`를 호출할 때마다 모든 버킷을 순회하며 개수를 세는 대신, 데이터 추가/삭제 시 `count` 변수를 갱신하여 $O(1)$ 시간 복잡도로 크기를 반환한다.
- **Clear**: 배열을 순회하며 비우는 대신, 새로운 배열을 할당하여 참조를 끊음으로써 가비지 컬렉션(GC)이 처리하도록 하여 효율성을 높였다.
