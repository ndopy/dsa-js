# 병합 정렬 (Merge Sort)

## 1. 개념
하나의 리스트를 두 개의 균등한 크기로 분할(Divide)하고, 분할된 부분 리스트를 정렬한 다음, 두 개의 정렬된 부분 리스트를 합쳐서(Merge) 전체를 정렬하는 알고리즘이다.<br/>
대표적인 **분할 정복(Divide and Conquer)** 알고리즘 중 하나이다.

## 2. 핵심 특징
1. **분할 정복:** 문제를 작은 문제로 쪼개서 해결한 뒤 다시 합치는 방식을 사용한다.
2. **안정 정렬 (Stable Sort):** 값이 같은 요소들의 상대적인 순서가 유지된다.
3. **성능 보장:** 입력 데이터의 상태(정렬 여부 등)와 상관없이 항상 일정한 성능을 보장한다.
4. **추가 메모리:** 정렬 과정에서 임시 배열이 필요하므로, 제자리 정렬(In-place Sorting)이 아니다. (공간 복잡도가 O(n)이다.)

## 3. 시간 복잡도 (Time Complexity)
1. **최악, 평균, 최선:** O(n log n)
   - 리스트를 반으로 나누는 과정이 log n번 반복되고, 각 단계에서 모든 요소를 병합하는 데 n만큼의 시간이 걸린다.
   - 퀵 정렬(Quick Sort)과 달리 최악의 경우에도 O(n log n)을 보장한다는 점이 큰 장점이다.

## 4. 구현 팁 (성능 최적화)
- **인덱스 활용:** `slice()`나 `shift()`를 사용하여 배열을 직접 자르고 수정하면 메모리 할당과 데이터 이동 오버헤드가 크다. 대신 원본 배열의 **인덱스(start, mid, end)** 를 전달하여 부분 범위를 지정하는 방식으로 구현하면 공간 복잡도와 성능을 개선할 수 있다.
- **보조 배열:** 병합 결과를 저장할 보조 배열을 매번 생성하지 않고, 전역(혹은 상위 스코프)에 한 번만 할당하여 재사용하는 것이 효율적이다.
- **Tim Sort:** 실무(Python, Java 등)에서는 병합 정렬과 삽입 정렬의 장점을 섞은 Tim Sort가 주로 사용된다. 작은 단위에서는 삽입 정렬을 쓰고, 이를 병합하는 방식을 취한다.