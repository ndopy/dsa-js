# 이중 연결 리스트 (Doubly Linked List)

## 개념
- 데이터를 담은 **노드(Node)** 가 이전 노드와 다음 노드의 주소를 모두 가지고 있는 자료구조이다.
- 단방향으로만 연결된 일반 연결 리스트와 달리, 양방향으로 이동할 수 있는 장점이 있다.

<br/>

## 추상자료형 ADT
| 함수 시그니처 | 시간 복잡도 | 설명 |
| --- | --- | --- |
| `insertAtFront(data)` | $O(1)$ | 리스트의 가장 앞에 데이터를 추가한다. |
| `insertAtBack(data)` | $O(1)$ | 리스트의 가장 뒤에 데이터를 추가한다. |
| `insertAt(index, data)` | $O(n)$ | 리스트의 특정 위치(index)에 새로운 데이터를 삽입한다. |
| `removeFront()` | $O(1)$ | 리스트의 첫 번째 데이터를 삭제하고 반환한다. |
| `removeBack()` | $O(1)$ | 리스트의 마지막 데이터를 삭제하고 반환한다. |
| `removeAt(index)` | $O(n)$ | 특정 위치(index)에 있는 데이터를 삭제하고, 삭제된 노드를 반환한다. |
| `get(index)` | $O(n)$ | 해당 인덱스에 위치한 데이터(data)를 반환한다. |
| `indexOf(data)` | $O(n)$ | 특정 데이터가 몇 번째 위치에 있는지 인덱스를 반환한다. |
| `clear()` | $O(1)$ | 리스트의 모든 데이터를 삭제하고 초기화한다. |
| `isEmpty()` | $O(1)$ | 리스트가 비어있는지 여부를 반환한다. |
| `toArray()` | $O(n)$ | 리스트의 모든 데이터를 배열로 변환하여 반환한다. |
| `printAll()` | $O(n)$ | 리스트 내의 모든 데이터를 배열 형태로 출력한다. |
| `length` (getter) | $O(1)$ | 리스트에 저장된 데이터의 개수를 반환한다. |

<br/>

## 내부 헬퍼 함수 (Private Methods)
| 함수 시그니처 | 설명 |
| --- | --- |
| `#validateIndex(type, index)` | 인덱스가 유효한 범위 내에 있는지 검사하고, 범위를 벗어나면 에러를 발생시킨다. |
| `#getNodeAt(index)` | 인덱스 위치에 따라 `head` 또는 `tail`에서 가까운 쪽부터 탐색하여 해당 노드를 반환한다. |

<br/>

## 핵심 로직

### 노드의 구성
- 각 노드는 데이터를 저장하는 `data`, 다음 노드를 가리키는 `next`, 이전 노드를 가리키는 `prev`를 가진다.
- 리스트의 시작은 `head`가, 끝은 `tail`이 관리하여 양방향 접근이 가능하다.

### 탐색 최적화 (`#getNodeAt`)
- 이중 연결 리스트의 장점을 살려, 찾으려는 인덱스가 전체 길이의 절반보다 앞쪽이면 `head`부터 탐색한다.
- 반대로 인덱스가 절반보다 뒤쪽이면 `tail`부터 역순으로 탐색하여 탐색 효율을 높인다.

### 삽입과 삭제
- 노드를 삽입하거나 삭제할 때 `next` 연결뿐만 아니라 `prev` 연결도 함께 수정해야 한다.
- `head`나 `tail`에서 작업할 때는 리스트가 비어있는 경우를 고려하여 `head`와 `tail`을 동시에 갱신해 주어야 한다.

<br/>

## 주의사항

### 양방향 연결 관리
- 데이터를 넣거나 뺄 때 `prev`, `next` 두 가지 연결을 모두 정확히 처리해야 한다. <br/> 하나라도 놓치면 연결이 끊어지거나 무한 루프에 빠질 수 있다.

### 예외 처리
- 인덱스 범위를 벗어나는 접근(`#validateIndex`)에 대해 철저히 확인해야 한다. <br/>특히 삽입 시에는 현재 길이까지 허용되지만, 삭제나 조회 시에는 마지막 인덱스까지만 허용한다는 점을 주의해야 한다.

### 메모리 관리
- 노드를 삭제할 때, 삭제되는 노드의 `next`나 `prev` 연결을 `null`로 만들어줌으로써, <br/> 더 이상 사용되지 않는 데이터가 명확히 정리되도록 관리한다.