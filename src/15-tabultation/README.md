# 타뷸레이션 (Tabulation)

## 1. 개념
동적 프로그래밍(Dynamic Programming)의 구현 방식 중 하나로, 작은 문제부터 시작하여 그 결과를 테이블(배열)에 저장하고, 이를 활용해 점차 큰 문제를 해결해 나가는 **상향식(Bottom-up)** 기법이다.

## 2. 핵심 특징
1. **접근 방식:** 재귀(Recursion)나 메모이제이션이 위에서 아래로 내려가는 하향식(Top-down)이라면, 타뷸레이션은 아래에서 위로 올라가는 **상향식(Bottom-up)** 접근 방식을 취한다.
2. **반복문 활용:** 재귀 함수 대신 `for` 문과 같은 반복문을 사용하여 구현하므로, 함수 호출로 인한 오버헤드가 없고 **스택 오버플로우(Stack Overflow)** 문제에서 자유롭다.
3. **테이블(Table):** 계산된 하위 문제의 결과를 저장하기 위해 배열(Array)을 사용하며, 이 배열을 채워 나가는 과정이라 하여 타뷸레이션이라 부른다.

## 3. 타뷸레이션 vs 메모이제이션
1. **메모이제이션 (Top-down):**
   - 필요한 하위 문제만 계산(Lazy Evaluation)한다는 장점이 있다.
   - 하지만 **재귀 호출로 인한 콜 스택(Call Stack)** 메모리를 추가로 사용하며, 깊이가 깊어지면 스택 오버플로우가 발생할 수 있다.
2. **타뷸레이션 (Bottom-up):**
   - 모든 하위 문제를 순차적으로 계산해야 한다.
   - 재귀 호출이 없어 **콜 스택 메모리를 사용하지 않으므로** 메모리 효율면에서 더 유리하다.
   - 또한, 필요 없는 과거 데이터를 버리는 **공간 최적화(Space Optimization)** 가 용이하다.

## 4. 구현 팁 (성능 최적화)
### 1. 공간 최적화 (Space Optimization)
- **원리:** 점화식에서 $F(n)$을 구할 때 $F(n-1)$과 $F(n-2)$만 필요하다면, 그 이전의 값($F(n-3)$ 등)은 메모리에 유지할 필요가 없다.
- **구현:** 전체 배열(`table`)을 만드는 대신, 변수 두세 개만 사용하여 값을 덮어쓰는 방식(Sliding Window)으로 구현하면 공간 복잡도를 $O(N)$에서 $O(1)$로 획기적으로 줄일 수 있다.
- **비교:** 메모이제이션은 재귀 호출 스택을 유지해야 하므로 이러한 최적화가 어렵지만, 타뷸레이션은 순차적으로 진행하므로 과거 데이터를 과감히 버릴 수 있다.

**[코드 예시 비교]**

**1) 일반적인 타뷸레이션 (공간 복잡도 $O(N)$)**
```javascript
function fibonacci_tabulation(n) {
  if (n <= 1) return n;
  const table = [0, 1]; // 모든 결과를 저장하는 배열
  for (let i = 2; i <= n; i++) {
    table[i] = table[i - 2] + table[i - 1];
  }
  return table[n];
}
```

**2) 공간 최적화 타뷸레이션 (공간 복잡도 $O(1)$)**
```javascript
function fibonacci_optimized(n) {
  if (n <= 1) return n;
  let prev2 = 0; // F(i-2)
  let prev1 = 1; // F(i-1)
  let current = 0; // F(i)

  for (let i = 2; i <= n; i++) {
    current = prev2 + prev1; // 현재 값 계산
    // 슬라이딩 윈도우: 변수 갱신
    prev2 = prev1;
    prev1 = current;
  }
  return current;
}
```

### 2. 초기화
- 문제의 조건에 맞춰 테이블의 크기를 정하고, 기저 사례(Base Case) 값을 미리 설정한 후 반복문을 시작한다.

## 5. 실습 예제
- 피보나치 수열